{"filter":false,"title":"Utils.cpp","tooltip":"/Utils.cpp","undoManager":{"mark":0,"position":0,"stack":[[{"group":"doc","deltas":[{"start":{"row":0,"column":0},"end":{"row":382,"column":1},"action":"remove","lines":["#include <iostream>","#include \"Utils.h\"","","std::vector<cv::Vec3b> field;","std::vector<int> pix(9);","std::vector<int>::iterator it;","","int med, i;","","std::vector<int> blue(9);","std::vector<int> green(9);","std::vector<int> red(9);","","int medBlue;","int medGreen;","int medRed;","","cv::Vec3b* pixel;","","/**"," * Gets the direct neighbors of a pixel","*/","void DirectNeighbors(int x, int y, cv::Mat& img)","{","    //cout << \"x: \" << x << endl;","    if(x == 0 && y == 0)","    {","        //Left-upper corner. Only 4 pixels needed","        //vector<cv::Vec3b> field(4);","        field.resize(4);","        field.at(0) = img.at<cv::Vec3b>(y, x);","        field.at(1) = img.at<cv::Vec3b>(y, x+1);","        field.at(2) = img.at<cv::Vec3b>(y+1, x);","        field.at(3) = img.at<cv::Vec3b>(y+1, x+1);","        ","        return;","    }","","    if(x == img.cols -1 && y == 0)","    {","        //Right-upper corner. Only 4 pixels needed","        //vector<cv::Vec3b> field(4);","        field.resize(4);","        field.at(0) = img.at<cv::Vec3b>(y, x);","        field.at(1) = img.at<cv::Vec3b>(y, x-1);","        field.at(2) = img.at<cv::Vec3b>(y+1, x);","        field.at(3) = img.at<cv::Vec3b>(y+1, x-1);","","        return;","    }","","    if(x == 0 && y == img.rows - 1)","    {","        //Left-lower corner. Only 4 pixels needed","        //vector<cv::Vec3b> field(4);","        field.resize(4);","        field.at(0) = img.at<cv::Vec3b>(y, x);","        field.at(1) = img.at<cv::Vec3b>(y, x+1);","        field.at(2) = img.at<cv::Vec3b>(y-1, x);","        field.at(3) = img.at<cv::Vec3b>(y-1, x+1);","","        return;","    }","","    if(x == img.cols - 1 && y == img.rows - 1)","    {","        //Right-lower corner. Only 4 pixels needed","        //vector<cv::Vec3b> field(4);","        field.resize(4);","        field.at(0) = img.at<cv::Vec3b>(y, x);","        field.at(1) = img.at<cv::Vec3b>(y, x+1);","        field.at(2) = img.at<cv::Vec3b>(y-1, x);","        field.at(3) = img.at<cv::Vec3b>(y-1, x+1);","","        return;","    }","","    /* Check edges after */","","    if(x > 0 && y == 0)","    {","        //Upper edge. Only 6 pixels needed","        //vector<cv::Vec3b> field(6);","        field.resize(6);","        field.at(0) = img.at<cv::Vec3b>(y, x);","        field.at(1) = img.at<cv::Vec3b>(y, x-1);","        field.at(2) = img.at<cv::Vec3b>(y, x+1);","        field.at(3) = img.at<cv::Vec3b>(y+1, x-1);","        field.at(4) = img.at<cv::Vec3b>(y+1, x);","        field.at(5) = img.at<cv::Vec3b>(y+1, x+1);","        return;","    }","","    if(x == 0 && y > 0)","    {","        //Left edge. Only 6 pixels needed","        //vector<cv::Vec3b> field(6);","        field.resize(6);","        field.at(0) = img.at<cv::Vec3b>(y, x);","        field.at(1) = img.at<cv::Vec3b>(y-1, x);","        field.at(2) = img.at<cv::Vec3b>(y+1, x);","        field.at(3) = img.at<cv::Vec3b>(y-1, x+1);","        field.at(4) = img.at<cv::Vec3b>(y, x+1);","        field.at(5) = img.at<cv::Vec3b>(y+1, x+1);","        return;","    }","","    if(x == img.cols - 1 && y > 0)","    {","        //Right edge. Only 6 pixels needed","        //vector<cv::Vec3b> field(6);","        field.resize(6);","        field.at(0) = img.at<cv::Vec3b>(y, x);","        field.at(1) = img.at<cv::Vec3b>(y-1, x);","        field.at(2) = img.at<cv::Vec3b>(y+1, x);","        field.at(3) = img.at<cv::Vec3b>(y-1, x-1);","        field.at(4) = img.at<cv::Vec3b>(y, x-1);","        field.at(5) = img.at<cv::Vec3b>(y+1, x-1);","        return;","    }","","    if(x > 0 && y == img.rows - 1)","    {","        //Bottom edge. Only 6 pixels needed","        //vector<cv::Vec3b> field(6);","        field.resize(6);","        field.at(0) = img.at<cv::Vec3b>(y, x);","        field.at(1) = img.at<cv::Vec3b>(y, x-1);","        field.at(2) = img.at<cv::Vec3b>(y, x+1);","        field.at(3) = img.at<cv::Vec3b>(y-1, x-1);","        field.at(4) = img.at<cv::Vec3b>(y-1, x);","        field.at(5) = img.at<cv::Vec3b>(y-1, x+1);","        return;","    }","","    /* No edges around the pixel. Return 9 pixels */","    //vector<cv::Vec3b> field(9);","    field.resize(9);","    field.at(0) = img.at<cv::Vec3b>(y-1, x-1);","    field.at(1) = img.at<cv::Vec3b>(y-1, x);","    field.at(2) = img.at<cv::Vec3b>(y-1, x+1);","    field.at(3) = img.at<cv::Vec3b>(y, x-1);","    field.at(4) = img.at<cv::Vec3b>(y, x);","    field.at(5) = img.at<cv::Vec3b>(y, x+1);","    field.at(6) = img.at<cv::Vec3b>(y+1, x-1);","    field.at(7) = img.at<cv::Vec3b>(y+1, x);","    field.at(8) = img.at<cv::Vec3b>(y+1, x+1);","","    return;","}","","/**"," * Gets the direct neighbors of a pixel"," * @return std::vector<cv::Vec3b> ->m BGR","*/","std::vector<cv::Vec3b> GetDirectNeighbors(int x, int y, cv::Mat& img)","{","    //cout << \"x: \" << x << endl;","    if(x == 0 && y == 0)","    {","        //Left-upper corner. Only 4 pixels needed","        //vector<cv::Vec3b> field(4);","        field.resize(4);","        field.at(0) = img.at<cv::Vec3b>(y, x);","        field.at(1) = img.at<cv::Vec3b>(y, x+1);","        field.at(2) = img.at<cv::Vec3b>(y+1, x);","        field.at(3) = img.at<cv::Vec3b>(y+1, x+1);","","        return field;","    }","","    if(x == img.cols -1 && y == 0)","    {","        //Right-upper corner. Only 4 pixels needed","        //vector<cv::Vec3b> field(4);","        field.resize(4);","        field.at(0) = img.at<cv::Vec3b>(y, x);","        field.at(1) = img.at<cv::Vec3b>(y, x-1);","        field.at(2) = img.at<cv::Vec3b>(y+1, x);","        field.at(3) = img.at<cv::Vec3b>(y+1, x-1);","","        return field;","    }","","    if(x == 0 && y == img.rows - 1)","    {","        //Left-lower corner. Only 4 pixels needed","        //vector<cv::Vec3b> field(4);","        field.resize(4);","        field.at(0) = img.at<cv::Vec3b>(y, x);","        field.at(1) = img.at<cv::Vec3b>(y, x+1);","        field.at(2) = img.at<cv::Vec3b>(y-1, x);","        field.at(3) = img.at<cv::Vec3b>(y-1, x+1);","","        return field;","    }","","    if(x == img.cols - 1 && y == img.rows - 1)","    {","        //Right-lower corner. Only 4 pixels needed","        //vector<cv::Vec3b> field(4);","        field.resize(4);","        field.at(0) = img.at<cv::Vec3b>(y, x);","        field.at(1) = img.at<cv::Vec3b>(y, x+1);","        field.at(2) = img.at<cv::Vec3b>(y-1, x);","        field.at(3) = img.at<cv::Vec3b>(y-1, x+1);","","        return field;","    }","","    /* Check edges after */","","    if(x > 0 && y == 0)","    {","        //Upper edge. Only 6 pixels needed","        //vector<cv::Vec3b> field(6);","        field.resize(6);","        field.at(0) = img.at<cv::Vec3b>(y, x);","        field.at(1) = img.at<cv::Vec3b>(y, x-1);","        field.at(2) = img.at<cv::Vec3b>(y, x+1);","        field.at(3) = img.at<cv::Vec3b>(y+1, x-1);","        field.at(4) = img.at<cv::Vec3b>(y+1, x);","        field.at(5) = img.at<cv::Vec3b>(y+1, x+1);","        return field;","    }","","    if(x == 0 && y > 0)","    {","        //Left edge. Only 6 pixels needed","        //vector<cv::Vec3b> field(6);","        field.resize(6);","        field.at(0) = img.at<cv::Vec3b>(y, x);","        field.at(1) = img.at<cv::Vec3b>(y-1, x);","        field.at(2) = img.at<cv::Vec3b>(y+1, x);","        field.at(3) = img.at<cv::Vec3b>(y-1, x+1);","        field.at(4) = img.at<cv::Vec3b>(y, x+1);","        field.at(5) = img.at<cv::Vec3b>(y+1, x+1);","        return field;","    }","","    if(x == img.cols - 1 && y > 0)","    {","        //Right edge. Only 6 pixels needed","        //vector<cv::Vec3b> field(6);","        field.resize(6);","        field.at(0) = img.at<cv::Vec3b>(y, x);","        field.at(1) = img.at<cv::Vec3b>(y-1, x);","        field.at(2) = img.at<cv::Vec3b>(y+1, x);","        field.at(3) = img.at<cv::Vec3b>(y-1, x-1);","        field.at(4) = img.at<cv::Vec3b>(y, x-1);","        field.at(5) = img.at<cv::Vec3b>(y+1, x-1);","        return field;","    }","","    if(x > 0 && y == img.rows - 1)","    {","        //Bottom edge. Only 6 pixels needed","        //vector<cv::Vec3b> field(6);","        field.resize(6);","        field.at(0) = img.at<cv::Vec3b>(y, x);","        field.at(1) = img.at<cv::Vec3b>(y, x-1);","        field.at(2) = img.at<cv::Vec3b>(y, x+1);","        field.at(3) = img.at<cv::Vec3b>(y-1, x-1);","        field.at(4) = img.at<cv::Vec3b>(y-1, x);","        field.at(5) = img.at<cv::Vec3b>(y-1, x+1);","        return field;","    }","","    /* No edges around the pixel. Return 9 pixels */","    //vector<cv::Vec3b> field(9);","    field.resize(9);","    field.at(0) = img.at<cv::Vec3b>(y-1, x-1);","    field.at(1) = img.at<cv::Vec3b>(y-1, x);","    field.at(2) = img.at<cv::Vec3b>(y-1, x+1);","    field.at(3) = img.at<cv::Vec3b>(y, x-1);","    field.at(4) = img.at<cv::Vec3b>(y, x);","    field.at(5) = img.at<cv::Vec3b>(y, x+1);","    field.at(6) = img.at<cv::Vec3b>(y+1, x-1);","    field.at(7) = img.at<cv::Vec3b>(y+1, x);","    field.at(8) = img.at<cv::Vec3b>(y+1, x+1);","","    return field;","}","","/**"," * Computes the median of a pixel coordinate (x, y) from Mat::img "," * and sets it to Mat::out_img on the same coordinate"," * @param: int x, int y, Mat::img, Mat::out_img","*/","void ComputeMedian(int& x, int& y, cv::Mat& img, cv::Mat& out_img)","{","    // Check borders","    DirectNeighbors(x, y, img);","","    // Set sortable values to vector","    //vector<BGR> pixValues(field.size());","","    if(field.size() != 9)","    {","        blue.resize(field.size());","        green.resize(field.size());","        red.resize(field.size());","","        for(i = 0; i < field.size(); ++i)","        {","            blue.at(i) = field.at(i)[0]; //B","            green.at(i) = field.at(i)[1]; //G","            red.at(i) = field.at(i)[2]; //R","        }","","        //Median","        medBlue = Median(blue);","        medGreen = Median(green);","        medRed = Median(red);","","        cv::Vec3b color;","        color[0] = medBlue;","        color[1] = medGreen;","        color[2] = medRed;","","        out_img.at<cv::Vec3b>(y, x) = color;","        field.clear();","    }","    else{","","        pix.resize(field.size());","        for(i = 0; i < field.size(); i++)","        {","            pix.at(i) = (","                     field.at(i)[0]","                    + field.at(i)[1]","                    + field.at(i)[2]","            );","        }","","        med = Median(pix);","        it = find(pix.begin(), pix.end(), med);","        //it = std::lower_bound(pix.begin(), pix.end(), med);","        auto index = std::distance(pix.begin(), it);","        out_img.at<cv::Vec3b>(y, x) = field.at(index);","        ","        pix.clear();","        field.clear();","    }","}","","/**"," * Median value of a std::vector<int>"," * @note: Gets the vector as copy, so the sorting does not affcet the original vector"," * @param std::vector<int>"," * @return int median","*/","int Median(std::vector<int> vec)","{","    int median;","    size_t size = vec.size();","","    // Sort","    sort(vec.begin(), vec.end());","","    if (size  % 2 == 0)","        median = (vec[size / 2 - 1] + vec[size / 2]) / 2;","    else","        median = vec[size / 2];","","    //vector<int>().swap(vec);","    return median;","}","","/**"," * Sets median filter to Mat::img. Outputs Mat::out_img"," * @note: Gets the images as reference"," * @param Mat::img, Mat::out_img","*/","void MedianFilter(cv::Mat& img, cv::Mat& out_img)","{","    // Iterate trough pixels","    for(int y = 0; y < img.rows - 0; y++)","        for(int x = 0; x < img.cols - 0; x++)","        {","            ComputeMedian(x, y, img, out_img);","        }","}"]},{"start":{"row":0,"column":0},"end":{"row":383,"column":1},"action":"insert","lines":["#include <iostream>","#include \"Utils.h\"","","std::vector<cv::Vec3b> field;","std::vector<int> pix(9);","std::vector<int>::iterator it;","","int med, i;","","std::vector<int> blue(9);","std::vector<int> green(9);","std::vector<int> red(9);","","int medBlue;","int medGreen;","int medRed;","","/**"," * Gets the direct neighbors of a pixel and sets them into"," * std::vector<Vec3b> field -> Global variable","*/","void DirectNeighbors(int x, int y, cv::Mat& img)","{","    //cout << \"x: \" << x << endl;","    if(x == 0 && y == 0)","    {","        //Left-upper corner. Only 4 pixels needed","        //vector<cv::Vec3b> field(4);","        field.resize(4);","        field.at(0) = img.ptr<cv::Vec3b>(y)[x];","        field.at(1) = img.ptr<cv::Vec3b>(y)[x+1];","        field.at(2) = img.ptr<cv::Vec3b>(y+1)[x];","        field.at(3) = img.ptr<cv::Vec3b>(y+1)[x+1];","        ","        return;","    }","","    if(x == img.cols -1 && y == 0)","    {","        //Right-upper corner. Only 4 pixels needed","        //vector<cv::Vec3b> field(4);","        field.resize(4);","        field.at(0) = img.ptr<cv::Vec3b>(y)[x];","        field.at(1) = img.ptr<cv::Vec3b>(y)[x-1];","        field.at(2) = img.ptr<cv::Vec3b>(y+1)[x];","        field.at(3) = img.ptr<cv::Vec3b>(y+1)[x-1];","","        return;","    }","","    if(x == 0 && y == img.rows - 1)","    {","        //Left-lower corner. Only 4 pixels needed","        //vector<cv::Vec3b> field(4);","        field.resize(4);","        field.at(0) = img.ptr<cv::Vec3b>(y)[x];","        field.at(1) = img.ptr<cv::Vec3b>(y)[x+1];","        field.at(2) = img.ptr<cv::Vec3b>(y-1)[x];","        field.at(3) = img.ptr<cv::Vec3b>(y-1)[x+1];","","        return;","    }","","    if(x == img.cols - 1 && y == img.rows - 1)","    {","        //Right-lower corner. Only 4 pixels needed","        //vector<cv::Vec3b> field(4);","        field.resize(4);","        field.at(0) = img.ptr<cv::Vec3b>(y)[x];","        field.at(1) = img.ptr<cv::Vec3b>(y)[x+1];","        field.at(2) = img.ptr<cv::Vec3b>(y-1)[x];","        field.at(3) = img.ptr<cv::Vec3b>(y-1)[x+1];","","        return;","    }","","    /* Check edges after */","","    if(x > 0 && y == 0)","    {","        //Upper edge. Only 6 pixels needed","        //vector<cv::Vec3b> field(6);","        field.resize(6);","        field.at(0) = img.ptr<cv::Vec3b>(y)[x];","        field.at(1) = img.ptr<cv::Vec3b>(y)[x-1];","        field.at(2) = img.ptr<cv::Vec3b>(y)[x+1];","        field.at(3) = img.ptr<cv::Vec3b>(y+1)[x-1];","        field.at(4) = img.ptr<cv::Vec3b>(y+1)[x];","        field.at(5) = img.ptr<cv::Vec3b>(y+1)[x+1];","        return;","    }","","    if(x == 0 && y > 0)","    {","        //Left edge. Only 6 pixels needed","        //vector<cv::Vec3b> field(6);","        field.resize(6);","        field.at(0) = img.ptr<cv::Vec3b>(y)[x];","        field.at(1) = img.ptr<cv::Vec3b>(y-1)[x];","        field.at(2) = img.ptr<cv::Vec3b>(y+1)[x];","        field.at(3) = img.ptr<cv::Vec3b>(y-1)[x+1];","        field.at(4) = img.ptr<cv::Vec3b>(y)[x+1];","        field.at(5) = img.ptr<cv::Vec3b>(y+1)[x+1];","        return;","    }","","    if(x == img.cols - 1 && y > 0)","    {","        //Right edge. Only 6 pixels needed","        //vector<cv::Vec3b> field(6);","        field.resize(6);","        field.at(0) = img.ptr<cv::Vec3b>(y)[x];","        field.at(1) = img.ptr<cv::Vec3b>(y-1)[x];","        field.at(2) = img.ptr<cv::Vec3b>(y+1)[x];","        field.at(3) = img.ptr<cv::Vec3b>(y-1)[x-1];","        field.at(4) = img.ptr<cv::Vec3b>(y)[x-1];","        field.at(5) = img.ptr<cv::Vec3b>(y+1)[x-1];","        return;","    }","","    if(x > 0 && y == img.rows - 1)","    {","        //Bottom edge. Only 6 pixels needed","        //vector<cv::Vec3b> field(6);","        field.resize(6);","        field.at(0) = img.ptr<cv::Vec3b>(y)[x];","        field.at(1) = img.ptr<cv::Vec3b>(y)[x-1];","        field.at(2) = img.ptr<cv::Vec3b>(y)[x+1];","        field.at(3) = img.ptr<cv::Vec3b>(y-1)[x-1];","        field.at(4) = img.ptr<cv::Vec3b>(y-1)[x];","        field.at(5) = img.ptr<cv::Vec3b>(y-1)[x+1];","        return;","    }","","    /* No edges around the pixel. Return 9 pixels */","    //vector<cv::Vec3b> field(9);","    field.resize(9);","    field.at(0) = img.ptr<cv::Vec3b>(y-1)[x-1];","    field.at(1) = img.ptr<cv::Vec3b>(y-1)[x];","    field.at(2) = img.ptr<cv::Vec3b>(y-1)[x+1];","    field.at(3) = img.ptr<cv::Vec3b>(y)[x-1];","    field.at(4) = img.ptr<cv::Vec3b>(y)[x];","    field.at(5) = img.ptr<cv::Vec3b>(y)[x+1];","    field.at(6) = img.ptr<cv::Vec3b>(y+1)[x-1];","    field.at(7) = img.ptr<cv::Vec3b>(y+1)[x];","    field.at(8) = img.ptr<cv::Vec3b>(y+1)[y+1];","","    return;","}","","/**"," * Gets the direct neighbors of a pixel"," * @return std::vector<cv::Vec3b> ->m BGR","*/","std::vector<cv::Vec3b> GetDirectNeighbors(int x, int y, cv::Mat& img)","{","    //cout << \"x: \" << x << endl;","    if(x == 0 && y == 0)","    {","        //Left-upper corner. Only 4 pixels needed","        //vector<cv::Vec3b> field(4);","        field.resize(4);","        field.at(0) = img.ptr<cv::Vec3b>(y)[x];","        field.at(1) = img.ptr<cv::Vec3b>(y)[x+1];","        field.at(2) = img.ptr<cv::Vec3b>(y+1)[x];","        field.at(3) = img.ptr<cv::Vec3b>(y+1)[x+1];","        ","        return field;","    }","","    if(x == img.cols -1 && y == 0)","    {","        //Right-upper corner. Only 4 pixels needed","        //vector<cv::Vec3b> field(4);","        field.resize(4);","        field.at(0) = img.ptr<cv::Vec3b>(y)[x];","        field.at(1) = img.ptr<cv::Vec3b>(y)[x-1];","        field.at(2) = img.ptr<cv::Vec3b>(y+1)[x];","        field.at(3) = img.ptr<cv::Vec3b>(y+1)[x-1];","","        return field;","    }","","    if(x == 0 && y == img.rows - 1)","    {","        //Left-lower corner. Only 4 pixels needed","        //vector<cv::Vec3b> field(4);","        field.resize(4);","        field.at(0) = img.ptr<cv::Vec3b>(y)[x];","        field.at(1) = img.ptr<cv::Vec3b>(y)[x+1];","        field.at(2) = img.ptr<cv::Vec3b>(y-1)[x];","        field.at(3) = img.ptr<cv::Vec3b>(y-1)[x+1];","","        return field;","    }","","    if(x == img.cols - 1 && y == img.rows - 1)","    {","        //Right-lower corner. Only 4 pixels needed","        //vector<cv::Vec3b> field(4);","        field.resize(4);","        field.at(0) = img.ptr<cv::Vec3b>(y)[x];","        field.at(1) = img.ptr<cv::Vec3b>(y)[x+1];","        field.at(2) = img.ptr<cv::Vec3b>(y-1)[x];","        field.at(3) = img.ptr<cv::Vec3b>(y-1)[x+1];","","        return field;","    }","","    /* Check edges after */","","    if(x > 0 && y == 0)","    {","        //Upper edge. Only 6 pixels needed","        //vector<cv::Vec3b> field(6);","        field.resize(6);","        field.at(0) = img.ptr<cv::Vec3b>(y)[x];","        field.at(1) = img.ptr<cv::Vec3b>(y)[x-1];","        field.at(2) = img.ptr<cv::Vec3b>(y)[x+1];","        field.at(3) = img.ptr<cv::Vec3b>(y+1)[x-1];","        field.at(4) = img.ptr<cv::Vec3b>(y+1)[x];","        field.at(5) = img.ptr<cv::Vec3b>(y+1)[x+1];","        return field;","    }","","    if(x == 0 && y > 0)","    {","        //Left edge. Only 6 pixels needed","        //vector<cv::Vec3b> field(6);","        field.resize(6);","        field.at(0) = img.ptr<cv::Vec3b>(y)[x];","        field.at(1) = img.ptr<cv::Vec3b>(y-1)[x];","        field.at(2) = img.ptr<cv::Vec3b>(y+1)[x];","        field.at(3) = img.ptr<cv::Vec3b>(y-1)[x+1];","        field.at(4) = img.ptr<cv::Vec3b>(y)[x+1];","        field.at(5) = img.ptr<cv::Vec3b>(y+1)[x+1];","        return field;","    }","","    if(x == img.cols - 1 && y > 0)","    {","        //Right edge. Only 6 pixels needed","        //vector<cv::Vec3b> field(6);","        field.resize(6);","        field.at(0) = img.ptr<cv::Vec3b>(y)[x];","        field.at(1) = img.ptr<cv::Vec3b>(y-1)[x];","        field.at(2) = img.ptr<cv::Vec3b>(y+1)[x];","        field.at(3) = img.ptr<cv::Vec3b>(y-1)[x-1];","        field.at(4) = img.ptr<cv::Vec3b>(y)[x-1];","        field.at(5) = img.ptr<cv::Vec3b>(y+1)[x-1];","        return field;","    }","","    if(x > 0 && y == img.rows - 1)","    {","        //Bottom edge. Only 6 pixels needed","        //vector<cv::Vec3b> field(6);","        field.resize(6);","        field.at(0) = img.ptr<cv::Vec3b>(y)[x];","        field.at(1) = img.ptr<cv::Vec3b>(y)[x-1];","        field.at(2) = img.ptr<cv::Vec3b>(y)[x+1];","        field.at(3) = img.ptr<cv::Vec3b>(y-1)[x-1];","        field.at(4) = img.ptr<cv::Vec3b>(y-1)[x];","        field.at(5) = img.ptr<cv::Vec3b>(y-1)[x+1];","        return field;","    }","","    /* No edges around the pixel. Return 9 pixels */","    //vector<cv::Vec3b> field(9);","    field.resize(9);","    field.at(0) = img.ptr<cv::Vec3b>(y-1)[x-1];","    field.at(1) = img.ptr<cv::Vec3b>(y-1)[x];","    field.at(2) = img.ptr<cv::Vec3b>(y-1)[x+1];","    field.at(3) = img.ptr<cv::Vec3b>(y)[x-1];","    field.at(4) = img.ptr<cv::Vec3b>(y)[x];","    field.at(5) = img.ptr<cv::Vec3b>(y)[x+1];","    field.at(6) = img.ptr<cv::Vec3b>(y+1)[x-1];","    field.at(7) = img.ptr<cv::Vec3b>(y+1)[x];","    field.at(8) = img.ptr<cv::Vec3b>(y+1)[y+1];","","    return field;","}","","/**"," * Computes the median of a pixel coordinate (x, y) from Mat::img "," * and sets it to Mat::out_img on the same coordinate"," * @param: int x, int y, Mat::img, Mat::out_img","*/","void ComputeMedian(int& x, int& y, cv::Mat& img, cv::Mat& out_img)","{","    // Gets the direct neighbors of a pixel into a vector","    DirectNeighbors(x, y, img);","","    // If the pixel is an edge or a corner (direct neighbors are less than 9)","    // Get median of each channel and create new pixel","    if(field.size() < 9)","    {","        blue.resize(field.size());","        green.resize(field.size());","        red.resize(field.size());","","        for(i = 0; i < field.size(); ++i)","        {","            blue.at(i) = field.at(i)[0]; //B","            green.at(i) = field.at(i)[1]; //G","            red.at(i) = field.at(i)[2]; //R","        }","","        //Median","        medBlue = Median(blue);","        medGreen = Median(green);","        medRed = Median(red);","","        cv::Vec3b color;","        color[0] = medBlue;","        color[1] = medGreen;","        color[2] = medRed;","","        out_img.at<cv::Vec3b>(y, x) = color;","        field.clear();","    }","    else{","        // Since this will always be 9","        // Just set the index of the median values R+G+B of each pixel","        // This way is much faster","        pix.resize(field.size());","        for(i = 0; i < field.size(); i++)","        {","            pix.at(i) = (","                     field.at(i)[0]","                    + field.at(i)[1]","                    + field.at(i)[2]","            );","        }","","        med = Median(pix);","        ","        // Find the median value in the vector and set it to an iterator","        it = find(pix.begin(), pix.end(), med);","        auto index = std::distance(pix.begin(), it);","        out_img.at<cv::Vec3b>(y, x) = field.at(index);","        ","        pix.clear();","        field.clear();","    }","}","","/**"," * Median value of a std::vector<int>"," * @note: Gets the vector as copy, so the sorting does not affcet the original vector"," * @param std::vector<int>"," * @return int median","*/","int Median(std::vector<int> vec)","{","    int median;","    size_t size = vec.size();","","    // Sort","    sort(vec.begin(), vec.end());","","    if (size  % 2 == 0)","        median = (vec[size / 2 - 1] + vec[size / 2]) / 2;","    else","        median = vec[size / 2];","","    //vector<int>().swap(vec);","    return median;","}","","/**"," * Sets median filter to Mat::img. Outputs Mat::out_img"," * @note: Gets the images as reference"," * @param Mat::img, Mat::out_img","*/","void MedianFilter(cv::Mat& img, cv::Mat& out_img)","{","    // Iterating trough pixels","    for(int y = 0; y < img.rows - 0; y++)","        for(int x = 0; x < img.cols - 0; x++)","        {","            ComputeMedian(x, y, img, out_img);","        }","}"]}]}]]},"ace":{"folds":[],"scrolltop":4673,"scrollleft":0,"selection":{"start":{"row":383,"column":1},"end":{"row":383,"column":1},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":0},"timestamp":1423430134921,"hash":"2b5d2f8afefb9730e100fe8c48859aba97507aec"}