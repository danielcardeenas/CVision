{"changed":true,"filter":false,"title":"Filters.cpp","tooltip":"/Filters.cpp","value":"","undoManager":{"mark":-1,"position":0,"stack":[[{"group":"doc","deltas":[{"start":{"row":0,"column":0},"end":{"row":238,"column":1},"action":"remove","lines":["/**"," * Gets the direct neighbors of a pixel"," * @return std::vector<Vec3b> ->m BGR","*/","","void DirectNeighbors(int x, int y, Mat& img)","{","    //cout << \"x: \" << x << endl;","    if(x == 0 && y == 0)","    {","        //Left-upper corner. Only 4 pixels needed","        //vector<Vec3b> field(4);","        field.resize(4);","        field.at(0) = img.at<Vec3b>(y, x);","        field.at(1) = img.at<Vec3b>(y, x+1);","        field.at(2) = img.at<Vec3b>(y+1, x);","        field.at(3) = img.at<Vec3b>(y+1, x+1);","","        cout << \"L-U\" << endl;","        return;","    }","","    if(x == img.cols -1 && y == 0)","    {","        //Right-upper corner. Only 4 pixels needed","        //vector<Vec3b> field(4);","        field.resize(4);","        field.at(0) = img.at<Vec3b>(y, x);","        field.at(1) = img.at<Vec3b>(y, x-1);","        field.at(2) = img.at<Vec3b>(y+1, x);","        field.at(3) = img.at<Vec3b>(y+1, x-1);","","        cout << \"R-U\" << endl;","        corner += 1;","        return;","    }","","    if(x == 0 && y == img.rows - 1)","    {","        //Left-lower corner. Only 4 pixels needed","        //vector<Vec3b> field(4);","        field.resize(4);","        field.at(0) = img.at<Vec3b>(y, x);","        field.at(1) = img.at<Vec3b>(y, x+1);","        field.at(2) = img.at<Vec3b>(y-1, x);","        field.at(3) = img.at<Vec3b>(y-1, x+1);","","        cout << \"L-L\" << endl;","        return;","    }","","    if(x == img.cols - 1 && y == img.rows - 1)","    {","        //Right-lower corner. Only 4 pixels needed","        //vector<Vec3b> field(4);","        field.resize(4);","        field.at(0) = img.at<Vec3b>(y, x);","        field.at(1) = img.at<Vec3b>(y, x+1);","        field.at(2) = img.at<Vec3b>(y-1, x);","        field.at(3) = img.at<Vec3b>(y-1, x+1);","","        cout << \"R-L\" << endl;","        return;","    }","","    /* Check edges after */","","    if(x > 0 && y == 0)","    {","        //Upper edge. Only 6 pixels needed","        //vector<Vec3b> field(6);","        field.resize(6);","        field.at(0) = img.at<Vec3b>(y, x);","        field.at(1) = img.at<Vec3b>(y, x-1);","        field.at(2) = img.at<Vec3b>(y, x+1);","        field.at(3) = img.at<Vec3b>(y+1, x-1);","        field.at(4) = img.at<Vec3b>(y+1, x);","        field.at(5) = img.at<Vec3b>(y+1, x+1);","        return;","    }","","    if(x == 0 && y > 0)","    {","        //Left edge. Only 6 pixels needed","        //vector<Vec3b> field(6);","        field.resize(6);","        field.at(0) = img.at<Vec3b>(y, x);","        field.at(1) = img.at<Vec3b>(y-1, x);","        field.at(2) = img.at<Vec3b>(y+1, x);","        field.at(3) = img.at<Vec3b>(y-1, x+1);","        field.at(4) = img.at<Vec3b>(y, x+1);","        field.at(5) = img.at<Vec3b>(y+1, x+1);","        return;","    }","","    if(x == img.cols - 1 && y > 0)","    {","        //Right edge. Only 6 pixels needed","        //vector<Vec3b> field(6);","        field.resize(6);","        field.at(0) = img.at<Vec3b>(y, x);","        field.at(1) = img.at<Vec3b>(y-1, x);","        field.at(2) = img.at<Vec3b>(y+1, x);","        field.at(3) = img.at<Vec3b>(y-1, x-1);","        field.at(4) = img.at<Vec3b>(y, x-1);","        field.at(5) = img.at<Vec3b>(y+1, x-1);","        return;","    }","","    if(x > 0 && y == img.rows - 1)","    {","        //Bottom edge. Only 6 pixels needed","        //vector<Vec3b> field(6);","        field.resize(6);","        field.at(0) = img.at<Vec3b>(y, x);","        field.at(1) = img.at<Vec3b>(y, x-1);","        field.at(2) = img.at<Vec3b>(y, x+1);","        field.at(3) = img.at<Vec3b>(y-1, x-1);","        field.at(4) = img.at<Vec3b>(y-1, x);","        field.at(5) = img.at<Vec3b>(y-1, x+1);","        return;","    }","","    /* No edges around the pixel. Return 9 pixels */","    //vector<Vec3b> field(9);","    field.resize(9);","    field.at(0) = img.at<Vec3b>(y-1, x-1);","    field.at(1) = img.at<Vec3b>(y-1, x);","    field.at(2) = img.at<Vec3b>(y-1, x+1);","    field.at(3) = img.at<Vec3b>(y, x-1);","    field.at(4) = img.at<Vec3b>(y, x);","    field.at(5) = img.at<Vec3b>(y, x+1);","    field.at(6) = img.at<Vec3b>(y+1, x-1);","    field.at(7) = img.at<Vec3b>(y+1, x);","    field.at(8) = img.at<Vec3b>(y+1, x+1);","","    return;","","}","","/**"," * Computes the median of a pixel coordinate (x, y) from Mat::img "," * and sets it to Mat::out_img on the same coordinate"," * @param: int x, int y, Mat::img, Mat::out_img","*/","void ComputeMedian(int& x, int& y, Mat& img, Mat& out_img)","{","    // Check borders","    DirectNeighbors(x, y, img);","","    // Set sortable values to vector","    //vector<BGR> pixValues(field.size());","","    if(field.size() != 9)","    {","        blue.resize(field.size());","        green.resize(field.size());","        red.resize(field.size());","","        for(i = 0; i < field.size(); ++i)","        {","            blue.at(i) = field.at(i)[0]; //B","            green.at(i) = field.at(i)[1]; //G","            red.at(i) = field.at(i)[2]; //R","        }","","        //Median","        medBlue = Median(blue);","        medGreen = Median(green);","        medRed = Median(red);","","        Vec3b color;","        color[0] = medBlue;","        color[1] = medGreen;","        color[2] = medRed;","","        out_img.at<Vec3b>(y, x) = color;","        field.clear();","    }","    else{","","        pix.resize(field.size());","        for(i = 0; i < field.size(); i++)","        {","            pix.at(i) = (","                     field.at(i)[0]","                    + field.at(i)[1]","                    + field.at(i)[2]","            );","        }","","        med = Median(pix);","        it = find(pix.begin(), pix.end(), med);","        //it = std::lower_bound(pix.begin(), pix.end(), med);","        auto index = std::distance(pix.begin(), it);","        out_img.at<Vec3b>(y, x) = field.at(index);","        ","        pix.clear();","        field.clear();","    }","}","","/**"," * Median value of a std::vector<int>"," * @note: Gets the vector as copy, so the sorting does not affcet the original vector"," * @param std::vector<int>"," * @return int median","*/","int Median(vector<int> vec)","{","    int median;","    size_t size = vec.size();","","    // Sort","    sort(vec.begin(), vec.end());","","    if (size  % 2 == 0)","        median = (vec[size / 2 - 1] + vec[size / 2]) / 2;","    else","        median = vec[size / 2];","","    //vector<int>().swap(vec);","    return median;","}","","/**"," * Sets median filter to Mat::img. Outputs Mat::out_img"," * @note: Gets the images as reference"," * @param Mat::img, Mat::out_img","*/","void MedianFilter(Mat& img, Mat& out_img)","{","    // Start getting pixels","    for(int y = 0; y < img.rows - 0; y++)","        for(int x = 0; x < img.cols - 0; x++)","        {","            ComputeMedian(x, y, img, out_img);","        }","}"]}]}]]},"ace":{"folds":[],"scrolltop":0,"scrollleft":0,"selection":{"start":{"row":0,"column":0},"end":{"row":0,"column":0},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":0},"timestamp":1423257777031}